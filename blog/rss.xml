<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Rest Hooks Blog</title>
        <link>https://resthooks.io/blog</link>
        <description>Rest Hooks Blog</description>
        <lastBuildDate>Sun, 29 Aug 2021 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <item>
            <title><![CDATA[Experimental useController()]]></title>
            <link>https://resthooks.io/blog/2021/08/29/Experimental-useController</link>
            <guid>/2021/08/29/Experimental-useController</guid>
            <pubDate>Sun, 29 Aug 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[@rest-hooks/experimental is a new]]></description>
            <content:encoded><![CDATA[<p><a href="https://www.npmjs.com/package/@rest-hooks/experimental">@rest-hooks/experimental</a> is a new
package that allows us to quickly iterate on new designs by using them in production, which provides
feedback in ways not possible at design and testing phase.</p><p>This package is <strong>not</strong> api stable; it does follow semver, so it will never reach 1.0.
However, it is tested with the same rigor we expect with Rest Hooks
as we use it in production. It is recommend to use this for providing feedback or playing with designs,
unless you are willing to put in extra work to make migrations. Detailed migration guides will only be
provided upon upstreaming to the mainline packages.</p><p>Today this package comes with two new features:</p><p><strong><a href="./2021-08-29-Experimental-useController.md#usecontroller">useController()</a></strong></p><pre><code class="language-ts">const { fetch, invalidate, resetEntireStore } = useController();
fetch(MyResource.detail(), { id });
</code></pre><p><strong><a href="./2021-08-29-Experimental-useController.md#static-listpaginated">Resource.list().paginated()</a></strong></p><pre><code class="language-ts">class NewsResource extends Resource {
  static listPage&lt;T extends typeof NewsResource&gt;(this: T) {
    return this.list().paginated(({ cursor, ...rest }) =&gt; [rest]);
  }
}
</code></pre><h2>useController()</h2><p>:::tip Update</p><p>As of 6.1 <a href="https://resthooks.io/docs/api/useController">useController()</a> is now upstreamed into
Rest Hooks core packages</p><p>:::</p><h3>Usage</h3><pre><code class="language-tsx">import { useController } from &#x27;@rest-hooks/experimental&#x27;;

function MyComponent({ id }) {
  const { fetch, invalidate, resetEntireStore } = useController();

  const handleRefresh = useCallback(
    async e =&gt; {
      await fetch(MyResource.detail(), { id });
    },
    [fetch, id],
  );

  const handleSuspend = useCallback(
    async e =&gt; {
      await invalidate(MyResource.detail(), { id });
    },
    [invalidate, id],
  );

  const handleLogout = useCallback(
    async e =&gt; {
      resetEntireStore();
    },
    [resetEntireStore],
  );
}
</code></pre><p><a href="https://github.com/coinbase/rest-hooks/pull/1048">PR</a></p><h3>Motivation</h3><ul><li>Consolidate, simplify hooks</li><li>Consistent interface between managers and hooks</li><li>Global referential equality available everywhere (managers and updaters)</li><li>Simplify and consolidate TTL and error concepts</li><li>Less code in hooks = less work on rendering leaf nodes</li><li>Icing on cake: ez migration to EndpointInterface and flexible args support for hooks</li><li>Future breaking changes can allow ez migration with version strings sent to <code>useController({version: &#x27;v2&#x27;})</code></li></ul><h3>One hook, many endpoints</h3><p>The rules of hooks are very restrictive, so the less hooks you have to call, the more flexible. This also benefits render performance. In many cases you might want to fetch many different endpoints. What&#x27;s worse is if you don&#x27;t know which endpoints you might want to fetch upfront. With old design you&#x27;d have to hook up every <em>possible</em> one. This really destroys fetch-as-render pattern, as you want to be able to prefetch based on possible routes.</p><h4>Before</h4><pre><code class="language-tsx">const createUser = useFetcher(User.create());
const refreshUsers = useFetcher(User.list());

return (
  &lt;form onSubmit={() =&gt; createUser({}, userPayload)}&gt;
    &lt;button onClick={() =&gt; refreshUsers({})}&gt;Refresh list&lt;/button&gt;
  &lt;/form&gt;
);
</code></pre><h4>After</h4><pre><code class="language-tsx">const { fetch } = useController();

return (
  &lt;form onSubmit={() =&gt; fetch(User.create(), {}, userPayload)}&gt;
    &lt;button onClick={() =&gt; fetch(User.list(), {})}&gt;Refresh list&lt;/button&gt;
  &lt;/form&gt;
);
</code></pre><h3>Completely flexible, variable arguments</h3><p>The concept of params + body for arguments was introduced to try to provide the most flexible approach in a world where type enforcement wasn&#x27;t that flexible. With TypeScript 4&#x27;s variadic tuples, it&#x27;s now possible to strongly type arbitrary arguments to a function in a <em>generic</em> way. Furthermore, stumbling upon package.json&#x27;s typeVersions, rest hooks can now publish multiple type versions to be compatible with different versions of typescript. This allows us to eagerly adopt TypeScript 4 features, while providing a usable TypeScript 3 experience.</p><p>Some common annoyances with the current parameter limitations are single-variable arguments like detail endpoints with an id, as well as no-argument case like a list endpoint or create endpoint.</p><pre><code class="language-tsx">const { fetch } = useController();

return (
  &lt;form onSubmit={() =&gt; fetch(User.create(), userPayload)}&gt;
    &lt;button onClick={() =&gt; fetch(User.list())}&gt;Refresh list&lt;/button&gt;
  &lt;/form&gt;
);
</code></pre><p>We&#x27;ll also eventually bring this to the &#x27;read&#x27; hooks like so:</p><pre><code class="language-tsx">// notice username is just a string, rather than object
const user = useResource(User.detail(), username);
// here we don&#x27;t need arguments
const posts = useResource(Post.list());
// but list() has it being optional, which means this also works:
const goodPosts = useResource(Post.list(), { good: true });
// postId is a number in this case
const thePost = useResource(Post.detail(), postId);
</code></pre><h3>Endpoint.update</h3><p>By normalizing <a href="https://resthooks.io/docs/api/Entity">Entities</a>, Rest Hooks guarantees data integrity and consistency even down to the referential equality level. However, there are still some cases where side effects result in changes to the actual results themselves. The most common reason for this is creation of new entities. While &#x27;creation&#x27; is almost universally the cause for this (as deletion is handled more simply by delete schemas), the structure of data and where created elements go is not universal.</p><p>:::tip</p><p><strong>Start using this now!</strong> Though this is the only way to use the new Controller.fetch,
endpoints with <code>update</code> work with the old <a href="https://resthooks.io/docs/api/useFetcher">useFetcher()</a> hook as well.</p><p>:::</p><h4>Before</h4><p>Previously this was enabled by an optional third argument to the fetch <a href="https://resthooks.io/docs/api/useFetcher#updateparams-destendpoint-destparams-updatefunction">UpdateParams</a> enabling programmatic changes that are also strictly type enforced to ensure the data integrity of the Rest Hooks store.</p><pre><code class="language-typescript">const createUser = new Endpoint(postToUserFunction, {
  schema: User,
});

const createUser = useFetcher(createUser);

createUser({}, { id: 1 }, [
  [
    userList,
    {},
    (newUserID: string, userIDs: string[] | undefined) =&gt; [
      ...(userIDs || []),
      newUserID,
    ],
  ],
]);
</code></pre><p>While simple, this design had several shortcomings</p><ul><li>Only operates on the normalized results, often arrays of strings<ul><li>This is non-intuitive as this doesn&#x27;t relate directly to the data&#x27;s form and requires understanding of internals</li><li>Code is confusing with two ordered args and necessary default handling</li></ul></li><li>Is provided as an argument to the fetch rather than endpoint<ul><li>Makes variable arguments impossible, and hard to reason about</li><li>Makes pattern reuse still require explicit wiring</li><li>Was thought to be more flexible than in &#x27;fetchshape&#x27;, as it has access to local variables in its event handler. However, Endpoints&#x27;s can easily use <code>.extend()</code> to contextually override so this feature is moot.</li><li>Encourages antipatterns like writing hooks for specific endpoints</li></ul></li></ul><h4>After</h4><ul><li>Move to Endpoint</li><li>builder pattern to make updater definition easy<ul><li>typeahead</li><li>strong type enforcement</li><li>much more readable than a size 3 tuple</li></ul></li></ul><p>Simplest case:</p><pre><code class="language-ts" metastring="title=&quot;userEndpoint.ts&quot;" title="&quot;userEndpoint.ts&quot;">const createUser = new Endpoint(postToUserFunction, {
  schema: User,
  update: (newUserId: string) =&gt; ({
    [userList.key()]: (users = []) =&gt; [newUserId, ...users],
  }),
});
</code></pre><p>More updates:</p><pre><code class="language-typescript" metastring="title=&quot;Component.tsx&quot;" title="&quot;Component.tsx&quot;">const allusers = useResource(userList);
const adminUsers = useResource(userList, { admin: true });
</code></pre><p>The endpoint below ensures the new user shows up immediately in the usages above.</p><pre><code class="language-ts" metastring="title=&quot;userEndpoint.ts&quot;" title="&quot;userEndpoint.ts&quot;">const createUser = new Endpoint(postToUserFunction, {
  schema: User,
  update: (newUserId, newUser)  =&gt; {
    const updates = {
      [userList.key()]: (users = []) =&gt; [newUserId, ...users],
    ];
    if (newUser.isAdmin) {
      updates[userList.key({ admin: true })] = (users = []) =&gt; [newUserId, ...users];
    }
    return updates;
  },
});
</code></pre><p>This is usage with a <a href="https://resthooks.io/docs/api/Resource">Resource</a></p><pre><code class="language-typescript" metastring="title=&quot;TodoResource.ts&quot;" title="&quot;TodoResource.ts&quot;">import { Resource } from &#x27;@rest-hooks/rest&#x27;;

export default class TodoResource extends Resource {
  readonly id: number = 0;
  readonly userId: number = 0;
  readonly title: string = &#x27;&#x27;;
  readonly completed: boolean = false;

  pk() {
    return `${this.id}`;
  }

  static urlRoot = &#x27;https://jsonplaceholder.typicode.com/todos&#x27;;

  static create&lt;T extends typeof Resource&gt;(this: T) {
    const todoList = this.list();
    return super.create().extend({
      schema: this,
      // highlight-start
      update: (newResourceId: string) =&gt; ({
        [todoList.key({})]: (resourceIds: string[] = []) =&gt; [
          ...resourceIds,
          newResourceId,
        ],
      }),
      // highlight-end
    });
  }
}
</code></pre><h3>Resolution order</h3><p>This makes little difference in React 18 since renders are batched; however in React &lt; 18, this means that code after promise resolution will be executed before react renders - allowing actions that need to take place as a result of successful fetch. For example navigating off a deleted page after delete.</p><pre><code class="language-typescript">const handleDelete = useCallback(
  async e =&gt; {
    await fetch(MyResource.delete(), { id });
    history.push(&#x27;/&#x27;);
  },
  [fetch, id],
);
</code></pre><p>:::warning</p><p>It&#x27;s now recommended to wrap all fetches in act when testing like so:</p><pre><code class="language-ts">await act(async () =&gt; {
  await result.current.fetch(ComplexResource.detail(), {
    id: &#x27;5&#x27;,
  });
});
</code></pre><p>:::</p><p><a href="https://github.com/coinbase/rest-hooks/pull/1046">PR</a></p><h3>What&#x27;s Next</h3><p>Tentative plans look something like this:</p><pre><code class="language-ts">const controller = useController();

// actions
controller.fetch(UserResource.detail(), { id }); // sideEffects means no throttle, otherwise throttle
controller.receive(payload, UserResource.detail(), { id });
controller.invalidate(UserResource.detail(), { id });
controller.resetEntireStore();
controller.subscribe(UserResource.detail(), { id });
controller.unsubscribe(UserResource.detail(), { id });
// posisble new
controller.abort(UserResource.detail(), { id }); // only aborts if in flight
// note: to force fetch of sideEffect: undefined - call abort first
// this should enable good offline/online managers

// retrieval
const state = useContext(StateContext);
const [value, expiresAt] = controller.getResponse(
  state,
  UserResource.detail(),
  { id },
);
const error = controller.getError(state, UserResource.detail(), { id });
</code></pre><h2>Resource changes</h2><h3>static list().paginated()</h3><h4>Motivation</h4><p>Pagination is a common scenario, that would benefit from minimal specification.</p><h4>Solution</h4><p>By default we rely on finding a list within the schema. The only remaining thing is figuring out how to extract the &#x27;cursor&#x27; args to update the main list. Therefore, a function to do just that should be provided by the user like so.</p><pre><code class="language-ts">class NewsResource extends Resource {
  static listPage&lt;T extends typeof NewsResource&gt;(this: T) {
    return this.list().paginated(({ cursor, ...rest }) =&gt; [rest]);
  }
}
</code></pre><pre><code class="language-tsx">import { useResource } from &#x27;rest-hooks&#x27;;
import NewsResource from &#x27;resources/NewsResource&#x27;;

function NewsList() {
  const { results, cursor } = useResource(NewsResource.list(), {});
  const curRef = useRef(cursor);
  curRef.current = cursor;
  const fetch = useFetcher();
  const getNextPage = useCallback(
    () =&gt; fetch(NewsResource.listPage(), { cursor: curRef.current }),
    [],
  );

  return (
    &lt;Pagination onPaginate={getNextPage} nextCursor={cursor}&gt;
      &lt;NewsList data={results} /&gt;
    &lt;/Pagination&gt;
  );
}
</code></pre><p><a href="https://github.com/coinbase/rest-hooks/pull/868">PR</a></p><h3>New Hiearchy</h3><p>Not every Resource has the same endpoints. It may have additional methods to CRUD, or
it could only support some operations. Furthermore, the exact nature and typings of endpoints
could vary widely making it hard to define a good base class, while also providing very specific types.</p><p>That&#x27;s why there is a new <code>BaseResource</code> that includes everything Resource had, but with
absolutely no endpoints. Instead it comes with an extensible &#x27;abstract endpoint&#x27; BaseResource.endpoint()
for side-effect free endpoints, as well as BaseResource.endpointMutate().</p><p><code>Resource</code> is still provided, by simplying extending one of these endpoints like so</p><pre><code class="language-typescript">abstract class Resource extends BaseResource {
  /** Endpoint to get a single entity */
  static detail&lt;T extends typeof Resource&gt;(
    this: T,
  ): RestEndpoint&lt;
    (this: RestEndpoint, params: any) =&gt; Promise&lt;any&gt;,
    SchemaDetail&lt;AbstractInstanceType&lt;T&gt;&gt;,
    undefined
  &gt; {
    const endpoint = this.endpoint();
    return this.memo(&#x27;#detail&#x27;, () =&gt;
      endpoint.extend({
        schema: this,
      }),
    );
  }
  // etc
}
</code></pre><p>This should make it much easier to get started quickly, while allowing for a powerful yet flexible
options in <code>BaseResource</code>. We expect most medium-to-large applications to mostly use this class.</p><p><a href="https://github.com/coinbase/rest-hooks/pull/841">PR</a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Rest Hooks 4.2-4.5]]></title>
            <link>https://resthooks.io/blog/2020/02/18/Rest-Hooks-4.2-4.5</link>
            <guid>/2020/02/18/Rest-Hooks-4.2-4.5</guid>
            <pubDate>Tue, 18 Feb 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[A lot of exciting features have been developed recently, resulting in many feature releases.]]></description>
            <content:encoded><![CDATA[<p>A lot of exciting features have been developed recently, resulting in many feature releases.
We&#x27;ve been hard a work integrating them into Coinbase&#x27;s various products, so I skipped a few
release announcements. The biggest focus has been performance features - highlighted by
adding true <a href="https://resthooks.io/docs/4.5/guides/optimistic-updates">optimistic updates</a>.</p><h3>4.2:</h3><p><a href="https://github.com/coinbase/rest-hooks/issues/237">Indexes</a></p><p><a href="https://resthooks.io/docs/4.5/api/Index">Indexes</a> allow lookup by alternate fields other than the primary key</p><p><a href="https://github.com/coinbase/rest-hooks/releases/tag/rest-hooks%404.1.0">Full set of 4.1 release commits</a></p><h3>4.3:</h3><p><a href="https://github.com/coinbase/rest-hooks/issues/246">Optimistic updates</a>
<a href="https://github.com/coinbase/rest-hooks/issues/251">Keep referential equality in list views</a></p><h3>4.4</h3><ul><li>SetShapeParams</li><li>ParamsFromShape</li><li>Export EntitySchema and EntityInstance</li><li>Fixed react native listUrl bug</li></ul><h3>4.5</h3><ul><li>Include all FetchOptions in subscribe action (<a href="https://github.com/coinbase/rest-hooks/issues/265">https://github.com/coinbase/rest-hooks/issues/265</a>)</li><li>Support non JSON (aka binary) fetches (<a href="https://github.com/coinbase/rest-hooks/issues/267">https://github.com/coinbase/rest-hooks/issues/267</a>)</li></ul><p>Internal Breaking:
Changing middlewares results in a new dispatch that properly wraps those middlewares. Technically this is
a fix, but if you relied on the old behavior be careful!</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Rest Hooks 4.1 Released]]></title>
            <link>https://resthooks.io/blog/2020/01/06/Rest-Hooks-4.1-Released</link>
            <guid>/2020/01/06/Rest-Hooks-4.1-Released</guid>
            <pubDate>Mon, 06 Jan 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[4.1 comes with a more granular data definition hierarchy that will make it easier to]]></description>
            <content:encoded><![CDATA[<p>4.1 comes with a more granular data definition hierarchy that will make it easier to
write more API definitions. This marked by the introduction of a new member known
as <a href="/docs/4.1/api/Entity">Entity</a>. <code>Entity</code> only needs a <code>pk()</code> and <code>get key()</code>, as well
as member declarations to integrate fully.</p><h3>Entity</h3><ul><li>Useful for nested entities that don&#x27;t have endpoints like LatestPrice.</li><li>Useful for non-REST style APIs like GraphQL.</li><li>Simplifies defining nested entities.</li></ul><h3>New hierarchy:</h3><pre><code> SimpleRecord
      |
   Entity
      |
SimpleResource
      |
   Resource
</code></pre><h3>Deprecations:</h3><ul><li>Resource.getKey() -&gt; Resource.key</li><li>Resource.getEntitySchema() -&gt; Resource.asSchema()</li><li>Entity.define() -&gt; override Entity.schema</li></ul><h3>Changes:</h3><ul><li>Normalizr: top level key sent to getId is undefined not null</li><li>pk() now takes additional parent, and key optional args</li><li>pk() no longer accepts number return value (run .toString())</li></ul><p><a href="https://github.com/coinbase/rest-hooks/releases/tag/rest-hooks%404.1.0">Full set of 4.1 release commits</a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Rest Hooks 4.0 Released]]></title>
            <link>https://resthooks.io/blog/2019/12/24/Rest-Hooks-4.0-Released</link>
            <guid>/2019/12/24/Rest-Hooks-4.0-Released</guid>
            <pubDate>Tue, 24 Dec 2019 00:00:00 GMT</pubDate>
            <description><![CDATA[4.0 marks the end of the migration to the new useCache() and useResource() implementations first]]></description>
            <content:encoded><![CDATA[<p>4.0 marks the end of the migration to the new useCache() and useResource() implementations first
introduced in 2.2. It also comes with a few other exciting features like a rewritten fetch based
on the actual browser <a href="https://developer.mozilla.org/en-US/docs/4.0/Web/API/Fetch_API">fetch API</a>.
Read below for more details and a <a href="#migration-guide">migration guide</a>.</p><h2>Drop legacy</h2><p>This marks the final stage of the rewritten selector hooks with useCacheLegacy() and useResourceLegacy() both
being completely removed.
These legacy versions removed in <a href="https://github.com/coinbase/rest-hooks/pull/170/files">#170</a> are wrappers
around the new versions. Because of this if you want to continue using those selectors you can simply
copy the code removed in <a href="https://github.com/coinbase/rest-hooks/pull/170/files">#170</a> into your own
application.</p><h2>Using fetch() out of the box</h2><p><a href="http://visionmedia.github.io/superagent/">Superagent</a> has a nice API using the <a href="https://en.wikipedia.org/wiki/Builder_pattern">Builder Pattern</a>, as well as working server-side out of the box which made it a great default fetch implementation.
However, it has not received much love recently and over time more functionality has been added to
the <a href="https://developer.mozilla.org/en-US/docs/4.0/Web/API/Fetch_API">fetch</a> standard. Furthermore,
developers have become increasingly familiar and used to it over other solutions.</p><p>For these reasons, we the default fetch implementation in <a href="https://resthooks.io/docs/4.0/api/Resource">Resource</a> now uses fetch. As such,
if you are targetting old (read: IE) browsers or want to run your code in node (for unit tests or server side rendering),
you&#x27;ll need to add a <a href="https://www.npmjs.com/package/whatwg-fetch">fetch polyfill</a>. <a href="https://www.npmjs.com/package/whatwg-fetch">whatwg-ftech</a>
is a great choice as it works both in node and in old browsers.</p><p>For those looking to continue using superagent, the old implementation is provided as an example <a href="https://resthooks.io/docs/4.0/guides/custom-networking#superagent">custom
fetch function</a>.</p><p>Along with this redesign comes some useful new ways of extending fetch for custom hooks.
Instead of <code>fetchPlugin</code>, there is a now a <code>fetchOptionsPlugin</code> which can be used to set
the <a href="https://developer.mozilla.org/en-US/docs/4.0/Web/API/WindowOrWorkerGlobalScope/fetch">fetch options</a> like adding headers.</p><p><a href="https://resthooks.io/docs/4.0/api/resource#static-fetchresponsemethod-get--post--put--patch--delete--options-url-string-body-readonlyobject--string--promiseresponse">fetchResponse()</a>
is exposed which does the bulk of the fetching besides reading the data itself. This can be useful when
building custom fetch shapes that need <a href="https://resthooks.io/docs/4.0/guides/network-transform#using-http-headers">access to things like headers</a>.
to build their response.</p><h2>New supplemental libraries</h2><p>Two new libraries were introduced in the last two months. These are both compatible with v3 and v4 of Rest Hooks.</p><h3><a href="https://www.npmjs.com/package/@rest-hooks/test">@rest-hooks/test</a></h3><p>Previously, <a href="https://resthooks.io/docs/4.0/guides/unit-testing-hooks">testing utilities</a> had been included in
rest-hooks package directly. These were pulled out into their own library and are no longer
included in v4 of Rest Hooks.</p><h3><a href="https://www.npmjs.com/package/@rest-hooks/legacy">@rest-hooks/legacy</a></h3><p>Legacy is a new package that included a hook similar to <a href="https://resthooks.io/docs/4.0/api/useresource">useResource()</a>, but that doesn&#x27;t use Suspense.
In practice this can be useful even when Suspense is used, as certain scenarios having stateful indicators
for loading and error states can actually be more ergonomic. This is also essential to integrate currently
with any Server Side Rendering.</p><p>Previously <a href="https://resthooks.io/docs/4.0/guides/no-suspense">useStatefulResource()</a> had been provided as
example code in the docs. However, since it was not tested it would often grow incompatible as underlying
changes were made to Rest Hooks itself.</p><p>Now it&#x27;s just an install and import away.</p><h2>Drop IE support in ES6 module</h2><p>Supporting Internet Explorer can be annoying. For many it is not even a requirement for their apps,
and so including library code with compatibility adapters can make the code bloated and even slower.</p><p>For this reason, those using a bundler that recognizes ES6 modules like webpack or parcel will load
a somewhat <a href="https://github.com/coinbase/rest-hooks/blob/rest-hooks%404.0.0/package.json#L25">modern target</a>.</p><p>If you plan on supporting IE, you&#x27;ll need to include transpiling Rest Hooks as part of your build process.
Note that Create React App already does this, so no work is needed in that case.</p><h2>Migration Guide</h2><ul><li>Transpile Rest Hooks if IE is to be supported</li><li>Remove useCacheLegacy() and useResourceLegacy()</li><li>rest-hooks/test -&gt; @rest-hooks/test</li><li>fetchPlugin -&gt; fetchOptionsPlugin, which builds on <a href="https://developer.mozilla.org/en-US/docs/4.0/Web/API/WindowOrWorkerGlobalScope/fetch">fetch options</a></li><li>No more SuperagentResource export</li><li>url() and listUrl() params are no longer optional (TypeScript)</li><li>Remove generic signatures to any Resource.fetch() overrides</li></ul><h2>Final notes</h2><p>Please try out the new release and <a href="https://github.com/coinbase/rest-hooks/issues">give feedback</a>
if there are any issues or if things are working great! We&#x27;ve got a lot of great new features
coming down the pipeline and we hope to see your contributions as well. 😊</p><p><a href="https://github.com/coinbase/rest-hooks/releases/tag/rest-hooks%404.0.0">Full set of 4.0 release commits</a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Rest Hooks 2.2 Released]]></title>
            <link>https://resthooks.io/blog/2019/10/28/Rest-Hooks-2.2-Released</link>
            <guid>/2019/10/28/Rest-Hooks-2.2-Released</guid>
            <pubDate>Mon, 28 Oct 2019 00:00:00 GMT</pubDate>
            <description><![CDATA[2.2 comes with the eagerly awaited programmable optimistic updates. This enables two very important use cases:]]></description>
            <content:encoded><![CDATA[<p>2.2 comes with the eagerly awaited programmable optimistic updates. This enables two very important use cases:
optimistic update on create and infinite pagination.</p><p>The bigger part of this release is introducing two new hooks that enable an incremental migration path to
3.0 planned changes. <a href="https://resthooks.io/docs/2.2/api/useCacheNew">useCacheNew()</a> and <a href="https://resthooks.io/docs/2.2/api/useresourcenew">useResourceNew()</a> are added in this release, allowing incremental adoption of the new selection logic
that will become the default in 3.0. More details below.</p><h2>Optimistic update on create</h2><p>Mutation fetches can often change more than just the entities in their response. For example,
issuing a create often means a subsequent request for a list of that resource will include the newly
created entity. Previously the workaround for this case would be to issue a fetch immediately after
the mutation request. This is not ideal as it causes unnecessary network traffic, server load, and most
importantly a slower user experience.</p><p>However, since updates like these can be extremely varied and implementation-dependant, providing a solution
that is protocol agnostic requires careful tuning. Inverting control can also be dangerous as
a small bug in user-code can destroy the entire cache structure.</p><p>Introducing <a href="https://resthooks.io/docs/2.2/api/useFetcher#updateparams-destshape-destparams-updatefunction">updateParams</a>
a new third argument to the imperative fetch function.</p><p>Each tuple in the array represents a result entry to update. The first two members of the tuple represent
that result, while the third is a function defining how to update it with the results of the fetch call.
TypeScript is invaluable here, as the very strict types ensure the function does not cause any cache state invariants
to be violated.</p><pre><code class="language-typescript">const createArticle = useFetcher(ArticleResource.createShape());

createArticle({ id: 1 }, {}, [
  [
    ArticleResource.listShape(),
    {},
    (newArticle, articles) =&gt; [...articles, newArticle],
  ],
]);
</code></pre><h3>Pagination</h3><p>This can also be used to support <a href="/docs/2.2/guides/infinite-scrolling-pagination">pagination</a>. Every time a new page is called, the results of that
page can be aggregated on one result list. Here&#x27;s the rough idea (this code hasn&#x27;t been tested):</p><pre><code class="language-typescript">class PaginatedArticleResource extends Resource {
  readonly id: number | null = null;
  readonly title: string = &#x27;&#x27;;
  readonly content: string = &#x27;&#x27;;
  readonly author: number | null = null;
  readonly tags: string[] = [];

  pk() {
    return this.id;
  }

  static urlRoot = &#x27;http://test.com/article/&#x27;;

  static listShape&lt;T extends typeof Resource&gt;(this: T) {
    return {
      ...super.listShape(),
      schema: { results: [this.getEntitySchema()] },
    };
  }
}

function mergeArticles(
  newPage: { results: string[] },
  articles: { results?: string[] },
): { results: string[] } {
  return [...(articles.results || []), ...newPage.results];
}

function useNextPageFetcher() {
  const getNextPage = useFetcher(ArticleResource.listShape());
  return useCallback(() =&gt; {
    return getNextPage({}, { cursor: 2 }, [
      [ArticleResource.listShape(), {}, mergeArticles],
    ]);
  }, [getNextPage]);
}
</code></pre><p><a href="https://github.com/coinbase/rest-hooks/pull/153">Add optimistic update on create + configurable optimistic updates</a></p><h2>useResourceNew() and useCacheNew()</h2><p>Previously for ‘convenience’ Rest Hooks’ selectors would automatically ‘dive’ into results - directly returning the first entity or list of entities it found. This seemed convenient but had the assumption that there would 1) always be an entity in a schema 2) be only one top-level entity. This is a pretty big assumption to make, and violates the principal of protocol agnosticism. Furthermore, this somewhat arbitrary behavior is not obvious and easily results in confusion to new users. Since the legacy selector behavior can easily be composed on top of selectors
returning the entire results, we have decided to move to a less opinionated version for the two selector hooks - <code>useCache()</code> and <code>useResource()</code>.</p><p>To make the transition easy, there are three phases. The first is in 2.2, which will introduce an opt-in to the new behavior by introducing
<a href="https://resthooks.io/docs/2.2/api/useresourcenew">useResourceNew()</a> and <a href="https://resthooks.io/docs/2.2/api/useCacheNew">useCacheNew()</a>. Upgrading to
2.2 allows incremental adoption of the new behavior one component at a time. Then in 3.0, the current <code>useResource()</code> and <code>useCache()</code> will be renamed to <code>useResourceLegacy()</code> and <code>useCacheLegacy()</code> respectively. The new hooks will then take their place. This makes upgrading a simple rename as well, providing an additional time window of incremental adoption. However, at that point these hooks should be considered deprecrated. Finally, in the next minor/major version, the legacy hooks will be removed altogether.</p><p><a href="https://github.com/coinbase/rest-hooks/pull/135">Add useResourceNew() and useCacheNew()</a></p><h2>useResetter()</h2><p><a href="https://resthooks.io/docs/2.2/api/useResetter">useResetter()</a> is a simple hook that makes clearing the entire cache imperatively quite simple. This can be useful in cases such as a user changing authentication state by login/logout.</p><p><a href="https://github.com/coinbase/rest-hooks/pull/148">Add useResetter() which returns a function that can clear entire cache</a></p><h2>Improved Union and Values support</h2><p>Additional tests and edge cases using Union and Value types have been added ensuring maximum schema flexibility.</p><p><a href="https://github.com/coinbase/rest-hooks/pull/135">Fully support Union and Values schemas in types and useDenormalized()</a></p><h2>Final notes</h2><p>Please try out the new release and <a href="https://github.com/coinbase/rest-hooks/issues">give feedback</a>
if there are any issues or if things are working great! We&#x27;ve got a lot of great new features
coming down the pipeline and we hope to see your contributions as well. 😊</p><p><a href="https://github.com/coinbase/rest-hooks/releases/tag/2.2.0">Full set of 2.2 release commits</a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Rest Hooks 2.1 Released]]></title>
            <link>https://resthooks.io/blog/2019/08/07/Rest-Hooks-2.1-Released</link>
            <guid>/2019/08/07/Rest-Hooks-2.1-Released</guid>
            <pubDate>Wed, 07 Aug 2019 00:00:00 GMT</pubDate>
            <description><![CDATA[New Features]]></description>
            <content:encoded><![CDATA[<h2>New Features</h2><h3>Reduced bundle size with custom networking library</h3><p>Resource comes with a default <code>fetch()</code> implementation to make getting started easy.
It uses <a href="http://visionmedia.github.io/superagent/">superagent</a> as the networking library
due to its server-side support as well as nice interface via the <a href="https://en.wikipedia.org/wiki/Builder_pattern">builder pattern</a>.
However, this comes at the cost of 6kb gziped added to the bundle. For those who want
to <a href="https://resthooks.io/docs/2.2/guides/custom-networking">use another networking library</a> this is quite a cost to pay for a library that itself
is well under 10kb gzip.</p><p>To solve this problem there is a new exported called <code>SimpleResource</code>. This provides
all the Resource behavior without the <code>fetch()</code> implementation. If you&#x27;re customizing
<code>fetch()</code> or want to customize <code>fetch()</code>, simply <a href="https://resthooks.io/docs/2.2/guides/custom-networking">follow the instructions</a> to use
SimpleResource as your base class now. With tree-shaking this will leave <a href="http://visionmedia.github.io/superagent/">superagent</a>
out of your bundle and save a cool 6kb gzip.</p><p><a href="https://github.com/coinbase/rest-hooks/pull/113">Enable customizing networking library reducing bundle size #113</a></p><h3>RPCAction, PurgeAction</h3><p>RPCAction, PurgeAction types join ReceiveAction and FetchAction as exportes from Rest Hooks.
Internally Rest Hooks dispatches actions (plain objects) that describe what Rest Hooks should do.
The structure of these actions is typed and previously only some of those types were actually
exported. Now you can get access to all of them. This is most useful for building your own <a href="https://resthooks.io/docs/2.2/api/Manager">custom
managers</a>.</p><p><a href="https://github.com/coinbase/rest-hooks/pull/119">Export new types RPCAction, PurgeAction #119</a></p><h2>Improved Debugging</h2><p>Sometimes the backend can fail and return bad responses - even without an HTTP error code.
It would behoove any fetching library to gracefully handle those cases and inform the user what
happened.</p><p>Previously there was a check for this very case - but it was only included in development mode.
Having certain bug checking code only exist in development mode makes sense for errors that
would exist and be caught in the client code. However, for issues independant of client (like
servers) this is an unreasonable restriction.</p><p>To solve this, the default <code>fetch()</code> implementation in <code>Resource</code> has been updated to
check for valid responses even in production. Its checking logic has also been improved.
Additionally the internal action dispatching types have been updated to not allow void
responses for anything besides a PurgeAction. This is important to enforce voids are not
passed around as they have no meaning as the result of a fetch. This leads the way to <a href="https://github.com/coinbase/rest-hooks/issues/120">further
type refinements that enforce this as the FetchShape.fetch()</a>
level as to ensure user implementations provide those same guarantees.</p><p>Now even in production - if the API soft errors by returning an invalid response without
an error status code you will get a &quot;JSON expected but not returned from API&quot; error response.</p><p><a href="https://github.com/coinbase/rest-hooks/pull/119">Handle null fetch response even in production #119</a></p><h2>Type refinements</h2><p><code>String</code> is considered a valid payload to be sent in requests, so it has been added to the union along
with <code>object</code>. This makes API really as flexible as it should be.</p><p><a href="https://github.com/coinbase/rest-hooks/pull/116">Allow string type for body (payload) parameters </a></p><h2>Final notes</h2><p>Please try out the new release and <a href="https://github.com/coinbase/rest-hooks/issues">give feedback</a>
if there are any issues or if things are working great! We&#x27;ve got a lot of great new features
coming down the pipeline and we hope to see your contributions as well. 😊</p><p><a href="https://github.com/coinbase/rest-hooks/releases/tag/2.1.0">Full set of 2.1 release commits</a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Announcing Rest Hooks 2.0]]></title>
            <link>https://resthooks.io/blog/2019/07/13/Announcing-Rest-Hooks-2.0</link>
            <guid>/2019/07/13/Announcing-Rest-Hooks-2.0</guid>
            <pubDate>Sat, 13 Jul 2019 00:00:00 GMT</pubDate>
            <description><![CDATA[We use SemVer for Rest Hooks - so 2.0 represents some breaking changes. To minimize disruption]]></description>
            <content:encoded><![CDATA[<p>We use <a href="https://semver.org/">SemVer</a> for Rest Hooks - so 2.0 represents some breaking changes. To minimize disruption
we have been carefully considering these changes and awaiting community feedback to be confident
these are the right changes to make.</p><p>While some of these changes are simple renames to make the library more intuitive - some represent
important progress to empowering the next chapter of Rest Hooks.</p><p>See <a href="https://github.com/coinbase/rest-hooks/releases/tag/2.0.0">https://github.com/coinbase/rest-hooks/releases/tag/2.0.0</a> for a complete list of changes</p><h2>Breaking changes</h2><p>Rest Hooks 2.0 mostly represents breaking changes. While some of these provide new functionality
or capabilities, purely additive features will come in subsequent releases.</p><h3>Renaming</h3><h4>RestProvider -&gt; CacheProvider</h4><p>The core provider has been renamed appropriately to represent what it actually does - manage
the cache. Since Rest Hooks is <strong>protocol agnostic</strong> by design it was not only misleading as name
but also didn&#x27;t sufficiently express what the provider is actually <em>providing</em>.</p><h4>RequestShape -&gt; FetchShape</h4><p><a href="/docs/2.2/api/FetchShape">FetchShape</a> is the core interface that enables Rest Hooks to be both
<strong>declarative</strong>, <strong>performant</strong> and <strong>protocol agnostic</strong>. The previous <code>Request</code> terminology
only represented one-side of the entire request/response pattern in fetch. This did not comprehensively
encapsulate the entirety of what it provided - thus we changed the name to <code>FetchShape</code> to capture
the full cycle of behavior - from request all the way to handling the response that it provides.</p><h4>Resource <code>FetchShape</code> generators</h4><p>Along the same lines, the provided static methods in <a href="/docs/2.2/api/resource">Resource</a> that return <code>FetchShapes</code>
need to accurately describe their return value. As such, the suffix has changed from <code>Request</code> to <code>Shape</code>. Also,
the request for getting a singular entity - typically using a lookup id - has had its prefix changed
from <code>single</code> to <code>detail</code> to better reflect common <code>REST</code> terminology.</p><ul><li>singleRequest() -&gt; detailShape()</li><li>listRequest() -&gt; listShape()</li><li>createRequest() -&gt; createShape()</li><li>updateRequest() -&gt; updateShape()</li><li>partialUpdateRequest() -&gt; partialUpdateShape()</li><li>deleteRequest() -&gt; deleteShape()</li></ul><h4>Schema types</h4><p>Previously there were two generic used to distinguish between <code>Schema</code>s that return a single item and many to
mark the expected return values of <code>detailShape()</code> and <code>listShape()</code>. Their names have been changed
to be consistent with the new naming. <code>SchemaBase</code> is now <code>SchemaDetail</code> and <code>SchemaArray</code> is now
<code>SchemaList</code>.</p><h3>Extensibility</h3><p>A core tenant of Rest Hooks&#x27; design is to be flexible to match diverse use cases. Along those
lines, some key improvements were made to enable easier extensibility and customization that will
empower the next wave of applications using Rest Hooks.</p><h4>CacheProvider and Managers</h4><p>The <a href="/docs/2.2/api/Manager">Manager</a> abstraction has existed since the beginning of Rest Hooks. The first Manager - <a href="/docs/2.2/api/NetworkManager">NetworkManager</a>
orchestrated the complex world of fetching. It provided performance optimizations like fetch deduplication
while providing Suspense promise resolution free of race conditions. This enabled the consistent bug-free behavior
of Rest Hooks while maintaining its minimal bundle footprint. Later the <a href="/docs/2.2/api/SubscriptionManager">SubscriptionManager</a> was added
to enable keeping resources fresh.</p><p>However, it quickly became clear that this was only the beginning. To enable the next generation of
Managers, <a href="/docs/2.2/api/CacheProvider">CacheProvider</a> now takes an <a href="/docs/2.2/api/CacheProvider#managers-manager">array of managers</a>
as a prop. As an undocumented behavior, the NetworkManager and SubscriptionManager
could previously be passed as arguments to customize their configuration. Instead
you can now override their defaults by sending both managers. Or build your own Managers
to be used as well.</p><h4>Protocol Agnostic</h4><p>Initially, FetchShape included a member to get the url (<code>getUrl()</code>). This was used to both
provide a lookup key for the results of a request as well as generate the url to send
to <code>fetch()</code> using an object of params like <code>{ id: 5 }</code>. This made it easy to override
just the url portion of a shape for custom endpoints.</p><p>However, for protocols that don&#x27;t base their requests on url like GraphQL this was a bit
awkward. Additionally, manipulating the request/response based on fetch params <a href="https://github.com/coinbase/rest-hooks/issues/87">became
cumbersome when the fetch method had to parse the url</a>
instead of just access those params itself.</p><ul><li><p><a href="/docs/2.2/guides/endpoints#rpc">getUrl() -&gt; getFetchKey() + fetch()</a></p><ul><li>If you were setting getUrl() before, you&#x27;ll need to also override the <a href="/docs/2.2/api/FetchShape#fetchparams-param-body-payload-promise-any">FetchShape.fetch()</a>. getFetchKey() is only used as a lookup
key in the results table cache. <a href="/docs/2.2/api/FetchShape#fetchparams-param-body-payload-promise-any">FetchShape.fetch()</a>
is responsible for constructing the actual url.</li></ul></li><li><p>fetch(url: string, body: Body) -&gt; fetch(params: Params, body: Body)</p></li></ul><h4>Hook composition</h4><p>One of the biggest benefits of hooks is enabling composition of behavior via isolation of
concerns. Even the highest level hooks in Rest Hooks have always been simply compositions of
other lower level hooks. However, without clear use cases of reuse - these lower level hooks
sometimes crossed appropriate abstraction boundaries.</p><p>One of these cases is the <code>useError()</code> hook, which now returns an error if one is found or
undefined otherwise. Previously it had been throwing the error itself, which made it awkward
to use outside the context of Error Boundaries
(e.g., <a href="/docs/2.2/guides/no-suspense#usestatefulresourcetsx">useStatefulResource</a>).</p><h3>Featherweight bundles</h3><p>Keeping Rest Hooks bundle footprint small has been a conscious effort - enabled mostly
by clean modular design. Sometimes this has to be balanced with maximum compatibility.
Keeping this in mind, Rest Hooks will now leave polyfill loading up to the user. Instead
of importing the polyfills it needs from core-js directly, it will assume they are loaded.
<strong>This means when using Rest Hooks 2.0 with the intent of IE compatibility - you will need
to ensure you are loading the appropriate polyfills yourself.</strong></p><p>Leaving polyfills in the control of the application builder seems like the best practice
for libraries. This also means an application can potentially only load polyfills if they
are needed.</p><h2>Migration guide</h2><p>To summarize:</p><ul><li>RestProvider -&gt; CacheProvider</li><li>RequestShape -&gt; FetchShape</li><li>singleRequest() -&gt; detailShape()</li><li>listRequest() -&gt; listShape()</li><li>createRequest() -&gt; createShape()</li><li>updateRequest() -&gt; updateShape()</li><li>partialUpdateRequest() -&gt; partialUpdateShape()</li><li>deleteRequest() -&gt; deleteShape()</li><li><code>&lt;CacheProvider manager={myNetworkManager} subscriptionManager={mySubcriptionManager}&gt;</code> -&gt; <code>&lt;CacheProvider managers={[myNetworkManager, mySubscriptionManager]}&gt;</code></li><li><a href="/docs/2.2/guides/endpoints#rpc">FetchShape.getUrl() -&gt; FetchShape.getFetchKey() + FetchShape.fetch()</a></li><li>FetchShape.fetch(url: string, body: Body) -&gt; FetchShape.fetch(params: Params, body: Body)</li><li>SchemaBase -&gt; SchemaDetail; SchemaArray -&gt; SchemaList</li><li>useError() returns error instead of throwing</li><li>Polyfills are not included automatically</li></ul><h2>What&#x27;s next</h2><p>While an important milestone for Rest Hooks, work is far from over. We have some exciting
features planned to be released soon. Here&#x27;s a sneak peak of the &#x27;soon&#x27; lineup:</p><ul><li>Garbage collection</li><li><a href="https://github.com/coinbase/rest-hooks/issues/96">Optimistic query update on create</a></li><li>Automatic query batching</li><li>Caching in Service Workers (PWA)</li><li>Server Side Rendering guide</li><li>Concurrent mode test suite</li></ul><p>We&#x27;re also experimenting with a CLI to generate <a href="/docs/2.2/api/resource">Resource</a> stubs from OpenAPI
schemas.</p><p>If any of these ideas excite you, or you have ideas of your own for Rest Hooks, we encourage you
to share your feedback by <a href="https://github.com/coinbase/rest-hooks/issues/new/choose">creating an issue</a>
or <a href="https://github.com/coinbase/rest-hooks/compare">contributing code</a>.</p>]]></content:encoded>
        </item>
    </channel>
</rss>